/*
 * PROTOCOL.h
 * inc
 * 
 * Copyright (C) 2025 by UHF Solutions
 * All right reserved
 */


#pragma once

#include <stdint.h>
#include <zephyr/kernel.h>



#define UNIVERSAL_TRANSPORT_HEAP_SIZE	16384

#define QUEUE_SIZE_USB_TX	64
#define QUEUE_SIZE_BLE_TX	32

#define QUEUE_SIZE_PARSER	16



extern struct k_heap UniversalTransportHeap;

typedef enum 
{
	MESSAGE_SOURCE_USB = 0,
	MESSAGE_SOURCE_BLE_CONNS,
} tMessageSources;

typedef struct
{
	tMessageSources source; // Номер источника. Всё, что >= MESSAGE_SOURCE_BLE_CONNS - индексы BLE подключений

	uint8_t *data;  		// Указатель на передаваемое сообщение 
	uint16_t length;		// Длина передаваемого сообщения
} tUniversalMessage;


typedef struct 
{
	tUniversalMessage *rxPacket;

	uint16_t payloadLength;
	uint16_t checksumBuffer;
} tParcingContext;



void freeUniversalMessage(tUniversalMessage *packet);
void freeParcingContex(tParcingContext *context);



#define PROTOCOL_PREAMBLE 0xBB
#define PROTOCOL_END_MARK 0x7E


#define PROTOCOL_INDEX_PREAMBLE		0
#define PROTOCOL_INDEX_MSG_TYPE		1
#define PROTOCOL_INDEX_MSG_CODE		2
#define PROTOCOL_INDEX_PL_LEN_MSB	3
#define PROTOCOL_INDEX_PL_LEN_LSB	4
#define PROTOCOL_INDEX_PL_START		5

#define PROTOCOL_END_PART_SIZE	3 // End Mark + CRC


#define PROTOCOL_MAX_PL_PACKET_LENGTH	4096
#define PROTOCOL_MAX_PACKET_LENGTH		PROTOCOL_INDEX_PL_START + PROTOCOL_MAX_PL_PACKET_LENGTH + PROTOCOL_END_PART_SIZE


//  Типы
#define PROTOCOL_MSG_TYPE_PR_COMMAND	0x00
#define PROTOCOL_MSG_TYPE_PR_ANSWER		0x01
#define PROTOCOL_MSG_TYPE_PR_NOTIFY		0x02

#define PROTOCOL_MSG_TYPE_COMMAND		0xE0
#define PROTOCOL_MSG_TYPE_ANSWER		0xE1
#define PROTOCOL_MSG_TYPE_NOTIFY		0xE2

#define PROTOCOL_MSG_TYPE_CRISP_COMMAND	0xE5
#define PROTOCOL_MSG_TYPE_CRISP_ANSWER	0xE6
#define PROTOCOL_MSG_TYPE_CRISP_NOTIFY	0xE7

#define PROTOCOL_MSG_TYPES { PROTOCOL_MSG_TYPE_PR_COMMAND, PROTOCOL_MSG_TYPE_PR_ANSWER, PROTOCOL_MSG_TYPE_PR_NOTIFY, \
						PROTOCOL_MSG_TYPE_COMMAND, PROTOCOL_MSG_TYPE_ANSWER, PROTOCOL_MSG_TYPE_NOTIFY, \
						PROTOCOL_MSG_TYPE_CRISP_COMMAND, PROTOCOL_MSG_TYPE_CRISP_ANSWER, PROTOCOL_MSG_TYPE_CRISP_NOTIFY }


//  Коды
#define PROTOCOL_MSG_CODE_GET_DEVICE_INFO		0x01
#define PROTOCOL_MSG_CODE_DO_SELF_CHECK			0x02
#define PROTOCOL_MSG_CODE_GET_ALL_USR_SETTINGS	0x10
#define PROTOCOL_MSG_CODE_GET_USR_SETTING		0x11
#define PROTOCOL_MSG_CODE_SET_USR_SETTING		0x12
#define PROTOCOL_MSG_CODE_GET_BATTERY_INFO		0x13
#define PROTOCOL_MSG_CODE_SET_SYSTEM_MODE		0x20
#define PROTOCOL_MSG_CODE_SET_SYSTEM_REG		0xF0
#define PROTOCOL_MSG_CODE_SET_LIFE_CYCLE		0xF1

// Результаты
#define PROTOCOL_RES_OK									0x0000
#define PROTOCOL_RES_HUK_VERIFICATION_ERROR				0x6401
#define PROTOCOL_RES_MEMORY_WRITE_ERROR					0x6501
#define PROTOCOL_RES_MEMORY_ERROR						0x6581
#define PROTOCOL_RES_RECEIVING_TIMEOUT_ERROR			0x6600
#define PROTOCOL_RES_RECEIVING_CRC_ERROR				0x6602
#define PROTOCOL_RES_WRONG_LENGTH_ERROR					0x6700
#define PROTOCOL_RES_CMD_NOT_ALLOWED_ERROR				0x6900
#define PROTOCOL_RES_SEC_CONDITION_NOT_SATISFIED_ERROR	0x6982
#define PROTOCOL_RES_SEC_PERMISSION_DENIED_ERROR		0x69F0
#define PROTOCOL_RES_WRONG_PARAMETERS_ERROR				0x6A00
#define PROTOCOL_RES_FUNCTION_NOT_SUPPORTED_ERROR		0x6A81
#define PROTOCOL_RES_INSUFFICIENT_MEMORY_ERROR			0x6A84
#define PROTOCOL_RES_REF_DATA_NOT_ROUND_ERROR			0x6A88
#define PROTOCOL_RES_FILE_ALREADY_EXISTS_ERROR			0x6A89
#define PROTOCOL_RES_INTERNAL_EXCEPTION_ERROR			0x6F00


#define PROTOCOL_PL_SIZE_DEVICE_INFO	0x0042

#define PROTOCOL_BEETWEN_DEVICE_INFO_1	0xC204
#define PROTOCOL_BEETWEN_DEVICE_INFO_2  0xC303
#define PROTOCOL_BEETWEN_DEVICE_INFO_3	0xC501
#define PROTOCOL_BEETWEN_DEVICE_INFO_4	0xC604
#define PROTOCOL_BEETWEN_DEVICE_INFO_5	0xC704
#define PROTOCOL_BEETWEN_DEVICE_INFO_6	0xC803
#define PROTOCOL_BEETWEN_DEVICE_INFO_7	0xC904
#define PROTOCOL_BEETWEN_DEVICE_INFO_8	0xCA04
#define PROTOCOL_BEETWEN_DEVICE_INFO_9	0xCB01
#define PROTOCOL_BEETWEN_DEVICE_INFO_10	0xCC03
#define PROTOCOL_BEETWEN_DEVICE_INFO_11	0xCD03
#define PROTOCOL_BEETWEN_DEVICE_INFO_12	0xCE03
#define PROTOCOL_BEETWEN_DEVICE_INFO_13	0xCE03



int protocolCheckMT(uint8_t MT);
int protocolCheckPayloadLength(uint16_t length);

uint16_t calculateCRC(uint8_t *data, uint16_t length);


/*
	Универсальная функция для парсинга приходящих пакетов. 
	Принимает новый	пришедший байт и контекст для каждого конкретного пакета 
	Возвращает <0 - если ошибка; 0 - если байт запарсен успешно; >0 - длина, если пакет запарсен успешно
*/

int parseNextByte(uint8_t newByte, tParcingContext *context);


